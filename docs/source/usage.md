(usage)=

# Usage

## Models

### URL

This is a custom data type taken from [httpx](https://www.python-httpx.org/) that wraps a basic string URL for better manipulation and inspection of a URL.
This is a really basic type, but it is used throughout the library as a standard for describing URLs.

You can quickly normalize a URL using the provided {func}`~megu.normalize_url` function.
For example:

```python
from megu import normalize_url
from megu.models import URL

string_url = "https://www.example.org/"
already_a_url = URL(string_url)

assert normalize_url(string_url) == already_a_url
assert normalize_url(already_a_url) == already_a_url
```

### Content

Defines some content discovered on a site (typically images, videos, audio, etc.) via {ref}`plugins` that we can reproduce locally.
This content is described by a custom data type {class}`~megu.models.Content` and has several properties to fully describe the content we can fetch:

```python
from megu.models import Content, ContentChecksum, ContentMetadata, HTTPResource, URL

content = Content(
  id="my-content",
  group="my-content",
  name="My Content",
  quality=1,
  size=1024,
  type="text/plain",
  url=URL("https://www.example.org/"),
  resources=[HTTPResource("GET", "https://example.org/")],
  checksums=[ContentChecksum("md5", "42bbd4ede89715b0a094e918e9105f5a")],
  extension=".txt",
  extra={},
  metadata=ContentMetadata()
)
```

#### Content ID

The unique identifier of some remote content.
If content being discovered by a plugin has multiple variants, then **this ID should be unique between all variants**.

Although you _could_ make use of UUIDs here, it is a better practice to try and describe the remote content using the ID as well as the [content name](#content-name).

:::{note}
Although it is not validated, this ID should **NOT** contain any whitespace or path separators (e.g. `/` on POSIX).
Doing so may introduce complications when writing the final content to the local machine.
:::

```python
image_content = Content(..., id="post-1234-image")
thumbnail_content = Content(..., id="post-1234-thumbnail")
```

#### Content Group

The identifier for some group of remote content.
If content being discovered by a plugin has multiple variants, then **this ID should be the same between all variants**.

We use this group identifier as a way of providing many variants of the same content from plugins and allowing users to filter down what specific variant of the content they want to fetch.

```python
image_content = Content(..., group="post-1234")
thumbnail_content = Content(..., group="post-1234")
```

#### Content Name

A human readable name describine the remote content variant.
This attribute has no requirements on being unique, its only purpose is to provide a decent name for the content than humans can understand.

```python
image_content = Content(..., name="Post Image")
thumbnail_content = Content(..., name="Post Image Thumbnail")
```

#### Content Quality

The relative quality of the remote content variant.
This quality is relative amoung the variants grouped by the [content group](#content-group).

Better quality content should have a larger value than the same content at worse quality.
For example, content describing an image and the image's thumbnail may use content qualities 1 and 0 respectfully.

```python
image_content = Content(..., quality=1)
thumbnail_content = Content(..., quality=0)
```

:::{tip}
This `quality` attribute supports floating numbers.
It is best practice for plugins to attempt to keep the range of content variant qualities between 0 and 1.
:::

#### Content Size

The size of the content variant in bytes.

```python
image_content = Content(..., size=4096)
thumbnail_content = Content(..., size=1024)
```

:::{important}
Plugins should **NOT** download the content in order to determine the content's size.
Usually this information can be aquired from the headers of a `HEAD` request to the [content resources](#content-resource) used to describe the content.
:::

#### Content Type

The [mime-type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of the content being fetched.
If no [content extension](#content-extension) is provided, this is used to guess the desired extension of the content when writing it to the local machine.

```python
image_content = Content(..., type="image/png")
thumbnail_content = Content(..., type="image/jpeg")
```

#### Content URL

The URL the content was discovered on.
This is potentially different from the URLs described in [content resources](#content-resource) as this URL should likely just be the URL that was provided to the plugin to discover content.

This URL should also be the same across all content generated by a plugin; regardless of group or content variants.

```python
image_content = Content(..., url=URL("https://example.org/"))
thumbnail_content = Content(..., url=URL("https://example.org/"))
```

#### Content Extension

The desired extension / suffix for the local file when the content is fetched.
This should include the suffix separator `.` (e.g. `.mp4`).

It is always desired to provide a valid extension for the content as guessing the extension from the [content type](#content-type) doesn't always use the appropriate extension.

```python
image_content = Content(..., extension=".png")
thumbnail_content = Content(..., extension=".jpg")
```

#### Content Extra

A generic dictionary of additional details regarding the content.
This extra dictionary of details should be unused by the library but may be useful to other tools or applications making use of the library.

```python
image_content = Content(..., extra={"discovered_at": datetime.utcnow().isoformat()})
thumbnail_content = Content(..., extra={"discovered_at": datetime.utcnow().isoformat()})
```

#### Content Resource

Defines some resources (at a given URL) that can be fetched to reproduce the content on the local machine.
This is ultimately just alist of request configurations that can be made by a supported downloader.

:::{note}
This could be any type resource that can be handled by a downloader.
However, we only provide the {class}`~megu.downloader.http.HTTPDownloader` right now, so the only resources that content can specify are instance of {class}`~megu.models.HTTPResource`.
:::

##### HTTP Resource

Describes a resource than is provided from an HTTP server and can be fetched through an HTTP request.
This resource simply wraps [httpx](https://www.python-httpx.org/)'s `Request` definition with a few extra properties for fingerprinting the request.

```python
image_content = Content(..., resources=[HTTPResource("GET", URL("https://example.org/image.png"))])
thumbnail_content = Content(..., resources=[HTTPResource("GET", URL("https://example.org/image-thumbnail.jpeg"))])
```

#### Content Checksum

In certain sittuations, we may have a checksum provided by the remote content that allows us to validate the content we download.
The {class}`~megu.models.ContentChecksum` data type allows us to specify a list of checksums to use to validate the downloaded content.

Checksum entries are completely optional for content.

```python
image_content = Content(..., checksums=[ContentChecksum("md5", "42bbd4ede89715b0a094e918e9105f5a")])
thumbnail_content = Content(..., checksums=[])
```

#### Content Metadata

Describes traditional structured metadata about the content we discovered.
See the {class}`~megu.models.ContentMetadata` data type to see the available properties that a plugin may be able to populate to better describe the discovered content.

This additional structured metadata is completely optional for content.

```python
image_content = Content(..., metadata=ContentMetadata(publisher="Stephen Bunn"))
thumbnail_content = Content(..., metadata=None)
```

### Content Manifest

The nature of downloading content with multiple resources means that we may end up with multiple artifacts that need to be combined on the local machine in order to fully reproduce the remote content.
The {class}`~megu.models.ContentManifest` is a simple type that describes the artifacts that were downloaded for some content.

It is the responsibility of the plugin that discovered the downloaded content to be able to use this manifest to write the content to a final destination path.

```python
manifest: ContentManifest = ("content-id", [("resource-fingerprint", artifact_filepath)])
```

## Discovering Content

The discovery of content is the responsibility of a plugin.
The library itself does not provide the functionality for discovering content from any specific site or application.

Assuming that you have a plugin available and registered to be used, you first have to get the most appropriate plugin to handle a given URL.
This can be done using the {func}`~megu.get_plugin` function:

```python
from megu import get_plugin, normalize_url

url = normalize_url("https://example.org/")
plugin = get_plugin(url)
```

This function will attempt to give you the best plugin to handle the URL you have provided.

:::{important}
If you have no plugins available to handle the provided URL, you should get the fallback plugin {class}`~megu.plugin.generic.GenericPlugin`.
This plugin assumes that it can handle any URL (which it cannot).
Any content generated from the {class}`~megu.plugin.generic.GenericPlugin` will likely not be the content you are interseted in.
:::

Using the plugin discovered from the {func}`~megu.get_plugin` function, we can iterate over the available content from the URL using the {func}`~megu.iter_content` function.
This function makes use of the discovered plugin to execute the logic to discover and yield {class}`~megu.models.Content` instances from the provided URL.

```python
from megu import iter_content, get_plugin, normalize_url

url = normalize_url("https://example.org/")
plugin = get_plugin(url)
for content in iter_content(plugin, url):
    print(content)
```

If desired, we can filter down what content to accept by making use of content filters.
The library provides a few in the {mod}`~megu.filters` module.

For example, the {func}`~megu.filters.best_content` filter only allows the best quality variant of content from each content group.

```python
from megu.filters import best_content

for content in best_content(iter_content(plugin, url)):
    print(content) # only the best content variant for each group
```

From here we can do additional filtering, or go straight to downloading the remote content using the most appropriate available downloader.

## Downloading Content

Given that we have some discovered content that we want to download to the local machine, we first need to discover the appropriate downloader to use for the content.
This can be achieved using the {func}`~megu.get_downloader` function.

```python
from megu import get_downloader

downloader = get_downloader(content)
```

:::{important}
Unlike the {func}`~megu.get_plugin` function, this function does not have a fallback downloader.
Instead, this function will raise a {class}`ValueError` if no downloader could be determined to handle the provided content.
:::

If we discover a downloader that can handle the content, we can make use of the {func}`~megu.download_content` function to download the content to a staging directory described by a {class}`~megu.models.ContentManifest`.

```python
from megu import download_content, get_downloader

downloader = get_downloader(content)
manifest = download_content(downloader, content)
```

By this point, the manifest should describe the content artifacts that were downloaded to the local machine.
Although they have not be processed and written to the final filepath by the plugin that discovered the content.

## Writing Content

The final step of fetching content is to have the plugin that discovered the content process it to its final location.
This is done using the {func}`~megu.write_content` function providing the original plugin and the content manifest.

```python
from megu import write_content

final_path = write_content(plugin, manifest, Path("~/Downloads/out").expanduser())
```

Since discovered content can have multiple resources that need to be fetched to produce some final content, it must be the plugin's responsibility to understand how to merge all the downloaded artifacts into the final content.

By the end of this, the remote content should exist at the final filepath.
